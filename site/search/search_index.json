{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LinAlgKit Documentation","text":"<p>Welcome to the LinAlgKit docs. This project provides a C++ linear algebra core with Python bindings via pybind11.</p> <ul> <li>Source: <code>matrixlib/</code></li> <li>Python package: <code>LinAlgKit</code> in <code>python_pkg/LinAlgKit/</code></li> <li>Build system: CMake + scikit-build-core</li> </ul>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Getting Started</li> <li>Python Usage</li> <li>C++ API Overview</li> <li>Performance Notes</li> <li>Benchmarks</li> <li>Releasing</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the project <code>README.md</code> for quick install and build instructions. For Python usage with editable install:</p> <pre><code>pip install -U pip scikit-build-core pybind11 numpy\nmkdir -p ~/linalgkit_build &amp;&amp; cd ~/linalgkit_build\npip install -e /path/to/repo\n</code></pre>"},{"location":"#python-usage","title":"Python Usage","text":"<pre><code>import numpy as np\nimport LinAlgKit as lk\n\nA = lk.Matrix.from_numpy(np.array([[1.0, 2.0],[3.0, 4.0]]))\nprint(A.determinant())\nB = A.transpose()\nprint(B.to_numpy())\n</code></pre>"},{"location":"#c-api-overview","title":"C++ API Overview","text":"<ul> <li><code>matrixlib::Matrix&lt;T&gt;</code> for arithmetic types (<code>int</code>, <code>float</code>, <code>double</code>).</li> <li>Operations: <code>+</code>, <code>-</code>, <code>*</code> (matrix-matrix, scalar), <code>transpose()</code>, <code>trace()</code>, <code>determinant()</code>.</li> <li>Static constructors: <code>identity(n)</code>, <code>zeros(r, c)</code>, <code>ones(r, c)</code>.</li> </ul> <p>See <code>include/matrixlib.h</code> for the full interface.</p>"},{"location":"#performance-notes","title":"Performance Notes","text":"<ul> <li>Determinant uses Bareiss fraction-free LU (O(n^3)).</li> <li>Naive recursive determinant kept for tests/tiny sizes.</li> <li>Current storage uses <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code> for simplicity. A contiguous layout would enable zero-copy NumPy views and faster BLAS-like ops.</li> </ul>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>See <code>benchmarks/benchmark_matrix.cpp</code>. Run after building with benchmarks enabled:</p> <pre><code>./bin/benchmarks/matrix_benchmarks\n</code></pre>"},{"location":"#releasing","title":"Releasing","text":"<p>See <code>docs/releasing.md</code>.</p>"},{"location":"api/","title":"API Reference (Python)","text":"<p>This reference documents the Python bindings exposed by <code>LinAlgKit</code> (via pybind11).</p>"},{"location":"api/#modules","title":"Modules","text":"<ul> <li><code>LinAlgKit</code></li> <li>Exposes classes: <code>Matrix</code> (double), <code>MatrixF</code> (float), <code>MatrixI</code> (int)</li> </ul>"},{"location":"api/#common-methods","title":"Common methods","text":"<p>All matrix types support the following operations unless noted.</p> <ul> <li>Constructor</li> <li><code>Matrix(rows: int, cols: int, value: number = 0)</code></li> <li>Properties</li> <li><code>rows: int</code></li> <li><code>cols: int</code></li> <li>Basic ops</li> <li><code>transpose() -&gt; Matrix</code></li> <li><code>trace() -&gt; number</code></li> <li><code>determinant() -&gt; number</code> (Bareiss/LU, O(n^3))</li> <li><code>determinant_naive() -&gt; number</code> (tiny matrices only)</li> <li>Arithmetic</li> <li><code>__add__(other: Matrix) -&gt; Matrix</code></li> <li><code>__sub__(other: Matrix) -&gt; Matrix</code></li> <li><code>__mul__(other: Matrix) -&gt; Matrix</code> (matrix multiplication)</li> <li><code>__rmul__(scalar: number) -&gt; Matrix</code> (scalar on left)</li> <li><code>scale(scalar: number) -&gt; Matrix</code> (alias for scalar multiply)</li> <li>Static constructors</li> <li><code>identity(size: int) -&gt; Matrix</code></li> <li><code>zeros(rows: int, cols: int) -&gt; Matrix</code></li> <li><code>ones(rows: int, cols: int) -&gt; Matrix</code></li> </ul>"},{"location":"api/#numpy-interop","title":"NumPy interop","text":"<ul> <li><code>Matrix.from_numpy(arr: numpy.ndarray) -&gt; Matrix</code></li> <li>Accepts 2D arrays; copies data into a new matrix.</li> <li><code>Matrix.to_numpy() -&gt; numpy.ndarray</code></li> <li>Returns a 2D array copy.</li> </ul>"},{"location":"api/#types","title":"Types","text":""},{"location":"api/#matrix-double","title":"Matrix (double)","text":"<p>Double-precision matrix. Exposed as <code>LinAlgKit.Matrix</code>.</p>"},{"location":"api/#matrixf-float","title":"MatrixF (float)","text":"<p>Single-precision matrix. Exposed as <code>LinAlgKit.MatrixF</code>.</p>"},{"location":"api/#matrixi-int","title":"MatrixI (int)","text":"<p>Integer matrix. Exposed as <code>LinAlgKit.MatrixI</code>.</p>"},{"location":"api/#notes","title":"Notes","text":"<ul> <li><code>inverse()</code> is implemented for 2x2 matrices. Larger sizes will use LU in a future release.</li> <li>Current storage is not contiguous; NumPy zero-copy views are not supported.</li> </ul>"},{"location":"performance/","title":"Performance Guide","text":"<p>This page explains the performance characteristics of LinAlgKit and how to reproduce benchmark results.</p>"},{"location":"performance/#determinant-algorithms","title":"Determinant algorithms","text":"<ul> <li><code>determinant()</code>: Bareiss fraction-free LU with partial pivoting; O(n^3), stable for integer matrices.</li> <li><code>determinant_naive()</code>: Laplace expansion; O(n!) \u2014 only for tiny matrices/testing.</li> </ul>"},{"location":"performance/#running-benchmarks","title":"Running benchmarks","text":"<p>Build with benchmarks enabled and run the harness:</p> <pre><code>mkdir -p ~/matrixlib_build &amp;&amp; cd ~/matrixlib_build\ncmake -G \"Unix Makefiles\" -DBUILD_BENCHMARKS=ON /path/to/repo\ncmake --build . -j\npython3 /path/to/repo/scripts/run_benchmarks.py --build-dir . --csv results.csv --plot results.png\n</code></pre> <p>The harness saves a CSV from Google Benchmark and optionally a simple bar plot (if matplotlib is installed).</p>"},{"location":"performance/#interpreting-benchmark-output","title":"Interpreting benchmark output","text":"<ul> <li><code>real_time</code> is the per-iteration runtime (ns), averaged over repetitions.</li> <li>Determinant (optimized) should scale roughly with O(n^3).</li> <li>Determinant (naive) grows factorially; use only up to n\u22488.</li> </ul>"},{"location":"performance/#tips","title":"Tips","text":"<ul> <li>Build <code>Release</code> for meaningful numbers.</li> <li>Avoid running on a heavily loaded system.</li> <li>For multi-run studies, pin CPU frequency/governor and isolate cores if possible.</li> </ul>"},{"location":"releasing/","title":"Releasing LinAlgKit","text":"<p>This document describes how to cut a new release, publish wheels to TestPyPI or PyPI, and verify the artifacts.</p>"},{"location":"releasing/#versioning","title":"Versioning","text":"<ul> <li>Bump the version in <code>pyproject.toml</code> under <code>[project] version</code>.</li> <li>Use tags of the form:</li> <li>Pre-release (goes to TestPyPI): <code>vX.Y.ZrcN</code>, <code>vX.Y.ZaN</code>, <code>vX.Y.ZbN</code>, or <code>vX.Y.ZdevN</code></li> <li>Stable (goes to PyPI): <code>vX.Y.Z</code></li> </ul>"},{"location":"releasing/#pre-release-checklist","title":"Pre-release checklist","text":"<ul> <li>Ensure CI is green on <code>main</code>.</li> <li>Update <code>README.md</code> and <code>CHANGELOG</code> (if present).</li> <li>Smoke test locally:   ```bash   # Build C++   mkdir -p ~/matrixlib_build &amp;&amp; cd ~/matrixlib_build   cmake -G \"Unix Makefiles\" -DBUILD_TESTS=ON -DBUILD_BENCHMARKS=OFF -DPYTHON_EXECUTABLE=$(which python3) /path/to/repo   cmake --build . -j   ctest --output-on-failure</li> </ul> <p># Python editable install &amp; smoke import   pip install -U pip scikit-build-core pybind11 numpy   pip install -e /path/to/repo   python - &lt;&lt;'PY' import LinAlgKit as lk m = lk.Matrix(2,2,1.0) print(\"OK:\", m.to_numpy().shape) PY   ```</p>"},{"location":"releasing/#testpypi-publish-optional-recommended","title":"TestPyPI publish (optional, recommended)","text":"<p>1) Build artifacts locally</p> <pre><code>python -m pip install -U build twine\npython -m build\n</code></pre> <p>2) Upload to TestPyPI</p> <pre><code># Create a token at https://test.pypi.org/account/ and set TWINE_PASSWORD env var\npython -m twine upload -r testpypi dist/*\n</code></pre> <p>3) Verify install from TestPyPI in a clean venv</p> <pre><code>python -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -i https://test.pypi.org/simple/ LinAlgKit\npython - &lt;&lt;'PY'\nimport LinAlgKit as lk\nprint(lk.Matrix(2,2,1.0).to_numpy())\nPY\n</code></pre>"},{"location":"releasing/#github-actions-publish-recommended","title":"GitHub Actions publish (recommended)","text":"<p>Publishing is automated via <code>.github/workflows/release.yml</code>:</p> <ul> <li>On pushing a tag <code>v*</code>, the workflow builds wheels (Linux/macOS/Windows) and an sdist.</li> <li>It uploads to TestPyPI for pre-release tags and PyPI for stable tags.</li> </ul>"},{"location":"releasing/#required-repository-secrets","title":"Required repository secrets","text":"<ul> <li><code>PYPI_API_TOKEN</code>: PyPI token with upload permissions.</li> <li><code>TEST_PYPI_API_TOKEN</code>: TestPyPI token with upload permissions.</li> </ul>"},{"location":"releasing/#triggering-a-release","title":"Triggering a release","text":"<pre><code>git tag v0.1.0rc1   # pre-release -&gt; TestPyPI\ngit push --tags\n# or stable\ngit tag v0.1.0\ngit push --tags\n</code></pre>"},{"location":"releasing/#post-release-verification","title":"Post-release verification","text":"<ul> <li>Install from the appropriate index:</li> </ul> <pre><code># Stable from PyPI\npip install LinAlgKit\n# Pre-release from TestPyPI\npip install -i https://test.pypi.org/simple/ LinAlgKit\n</code></pre> <ul> <li>Run a smoke test import and a small operation.</li> </ul>"},{"location":"releasing/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Missing <code>cmake</code>/compiler during build-from-source:</li> <li>Linux: <code>sudo apt-get install -y cmake build-essential python3-dev</code></li> <li>macOS: <code>xcode-select --install</code> (Command Line Tools)</li> <li>Windows: Visual Studio Build Tools (Desktop C++ workload)</li> <li>NumPy headers not found:</li> <li><code>pip install -U numpy</code> before installing LinAlgKit</li> <li>Windows/WSL file locks:</li> <li>Build in WSL <code>$HOME</code> and point CMake to Windows path instead of building on <code>/mnt/c</code>.</li> </ul>"},{"location":"tutorial/","title":"Tutorial: Python usage with NumPy interop","text":"<p>This tutorial shows how to use LinAlgKit from Python, including NumPy interop.</p>"},{"location":"tutorial/#setup","title":"Setup","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install -U pip numpy\n# If not installed already, install LinAlgKit from source or PyPI\n# pip install LinAlgKit\n</code></pre>"},{"location":"tutorial/#creating-matrices-from-numpy","title":"Creating matrices from NumPy","text":"<pre><code>import numpy as np\nimport LinAlgKit as lk\n\nA = lk.Matrix.from_numpy(np.array([[1.0, 2.0], [3.0, 4.0]]))\nB = lk.Matrix.from_numpy(np.eye(2))\nprint(\"A:\\n\", A.to_numpy())\nprint(\"B:\\n\", B.to_numpy())\n</code></pre>"},{"location":"tutorial/#basic-operations","title":"Basic operations","text":"<pre><code>C = A + B\nD = A - B\nE = A * B  # matrix-matrix\nF = A * 2.0  # scalar on right\nG = 3.0 * A  # scalar on left via __rmul__\n\nprint(\"C = A + B:\\n\", C.to_numpy())\nprint(\"D = A - B:\\n\", D.to_numpy())\nprint(\"E = A * B:\\n\", E.to_numpy())\nprint(\"F = A * 2:\\n\", F.to_numpy())\nprint(\"G = 3 * A:\\n\", G.to_numpy())\n</code></pre>"},{"location":"tutorial/#transpose-trace-determinant","title":"Transpose, trace, determinant","text":"<pre><code>AT = A.transpose()\nprint(\"A^T:\\n\", AT.to_numpy())\nprint(\"trace(A):\", A.trace())\nprint(\"det(A):\", A.determinant())  # Bareiss (fraction-free LU)\n</code></pre>"},{"location":"tutorial/#integer-and-float-matrices","title":"Integer and float matrices","text":"<pre><code>Ai = lk.MatrixI.from_numpy(np.array([[2, 0], [0, 2]], dtype=np.int32))\nAf = lk.MatrixF.from_numpy(np.ones((3, 3), dtype=np.float32))\nprint(\"Ai trace:\", Ai.trace())\nprint(\"Af shape:\", Af.rows, Af.cols)\n</code></pre>"},{"location":"tutorial/#converting-back-to-numpy","title":"Converting back to NumPy","text":"<pre><code>npA = A.to_numpy()\nprint(type(npA), npA.shape)\n</code></pre>"},{"location":"tutorial/#notes","title":"Notes","text":"<ul> <li><code>from_numpy</code> and <code>to_numpy</code> copy data in both directions.</li> <li>Currently, zero\u2011copy views are not supported due to the internal storage layout.</li> <li><code>inverse()</code> is implemented for 2x2 matrices; larger sizes will use LU in a future update.</li> </ul>"}]}